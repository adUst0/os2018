
# Упражнение 3

## I. Метасимволи в имената на файлове

**Def.** Метасимвол - символ със специално значение за bash

* **\*** - Разширява се до произволен брой произволни символи. 
* **?** - разширява се до един произволен символ.
* **[]** - разширява се до един символ от изброените в скобите
* **[^]** - един символ без изброените в скобите

**Пример**(от лекции): Нека в директорията имаме файловете:
* .bashrc
* a.o
* b.1.2
* c
* f
* f1
* fb
* file.c

| Шаблон | Списък от имена |
|--|--|
| f\* | f, f1, fb, file.c |
| \*c | c, file.c |
| f? | f1 fb |
| ?b\* | fb |
| [ab]\* | a.o b.1.2 |
| [a-c]\* | a.o b.1.2 c |
| [^ab]\* | c f f1 fb file.c |

## II.  Метасимволът `

```shell
`cmd`
```

Замества изразът с изхода от командата cmd

**Пример**: 

```shell
cal `expr 2018 – 4`
```
## III. Екраниране

**Def.** Екраниране на метасимволи - отнемане на специалното им значение

* **'низ'** - екранират се всички метасимволи
* **"низ"** - екранират се всички метасимволи без **$, \`, \\, "**
* **\symbol** - екранира се един символ

**Пример:** 
* `touch "My file with spaces"`
* `echo "Use \"A*\" for the implementation of this task"` - ще покаже кавичките около A*

## IV.  Пренасочване на вход и изход

**Важни файлови дескриптори:** 0 - stdin; 1 - stdout; 2 - stderr

* `cmd < file` - пренасочване на стандартния вход
* `cmd > file` - пренасочване на стандартния изход
* `cmd >> file` - пренасочване на стандартния изход в края на файла (append)
* `cmd 2> file; cmd 2>> file` - пренасочване на стандартния изход за грешки

`cmd > /dev/null` - скриване на изхода  

**Обща конструкция:**
* `[n]< file` - по подразбиране е 0 и е файлов дескриптор отворен за вход
* `[n]> file; [n]>> file` - по подразбиране е 1 и е файлов дескриптор отворен за изход
* `[n]>&m` - по подразбиране n = 1. n и m са файлови дескриптори за изход и изходите по двата дескриптора се сливат по файла, който е свързан с дескриптора m

**Примери:**
* `wc -c < f1` - символите във f1 = размера в байтове
* `ls -l > files`

## V.   Pipes (канал / конвейер)

```shell
cmd1 | cmd2 [| cmd3 …]
```

Изходът от **cmd1** се пренасочва директно към входа на **cmd2**. Изходът на **cmd2** се пренасочва към входа на **cmd3** и т.н.

**Примери:** 
* `who | grep pesho | wc -l` - колко сесии има потребителят pesho
* `ls | wc -l` - колко файла има в текущата директория
* `ls | head -3 | tail -1` - показва третия файл (по азбучен ред) в текущата директория
* `cmd | less` - показва изхода от командата „на страници“. 

## VI.  Фонов (асинхронен) режим на изпълнение

`cmd &` - командата се изпълнява във фонов режим и не се изчаква завършването ѝ. 

**N.B.** Команда, която се изпълнява във фонов режим и трябва да чете от stdin, получава празен файл. 

## Задачи

1. Напишете команда, която отпечатва всички файлове в текущата директория, чието име е с дължина 2 символа. А чието име се състои от 2 букви?

2. Напишете команда, която създава файл с информацията за всички файлове в текущата директория.

3. Запишете броя на редовете на файла от предната задача в нов файл.

4. Напишете команда, която извежда само първите 3 файла в текущата директория

5. Напишете команда, която извежда само името на третия файл в текущата директория

6. Напишете команда, която отпечатва името на всички файлове от root директорията (директориите също са файлове), които съдържат bin в името си.

7. Напишете команда, която намира всички файлове, завършващи на .c в /home и всички поддиректории. 

8. Напишете команда, която показва съдържанието на всички директории от root директорията, но това да става one screen at a time.

9. Напишете команда, която извежда броя на файловете в /home

10. Създайте нова директория zad2 и се позиционирайте в нея. Напишете команда, която за всяка директория в root директорията, създава празна директория със същото име. 

11. Напишете команда, която извежда броя на командите от историята ви, които съдържат стринга ls. (Използвайте командата history)
